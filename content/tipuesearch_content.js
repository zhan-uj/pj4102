var tipuesearch = {"pages": [{'title': 'About', 'text': '專題題目： 網際球賽機器人協同設計與模擬 \n Web-based Ball Game Robot Collaborative Design and Simulation \n \n 專題網站:  https://mde.tw/pj4102 \n 專題倉儲:  https://github.com/mdecycu/pj4102 \n 專題成員: \n 41023220 陳冠珉 \n 41023230 彭聖宗 \n 41023231 湛有杰  https://github.com/zhan-uj/pj4102 \n 41023232 雲敬家 \n 41071203 侯昀熙 \n \n 網際球賽機器人協同設計與模擬 \n 球賽設計: \n 每場競技時間為 10 分鐘 \n 每隊球員機器人依照各組人數平均分為兩隊 \n 雙方陣營各有足球門與籃球框各一具 \n 球場中由裁判程式於開場時, 在球場正中央落下 10 球 \n 將球踢進對方球門者得 1 分, 將球投入對方籃框者得 5 分 \n', 'tags': '', 'url': 'About.html'}, {'title': '專題摘要', 'text': '\n 網 際 球 賽 機 器 人 協 同 設 計 與 模 擬與 虛 實 整 合 \n \n 本專題以「 網際球賽機器人協同設計與模擬 」為主題，以 協同連線 與 虛實整合 為製作重點。 \n  運用 Autodesk Inventor 軟體設計了機器人球員及場地模型，並將 其導入 CoppeliaSim 虛擬環境中。這個虛擬場景包含了完整的球賽元 素，例如足球、球場、球門、籃板、籃框、記分板和計時器。  \n 利用 Python zmqRemoteAPI 程式來操控機器人動作。透過網路連線，使成員可以在各自的電腦上參與虛擬球賽。此設計讓玩家可以透 過協作，共同體驗虛擬球賽的樂趣。 \n  專題的核心目標之一是實現 虛 實 整 合 ，我們將 CoppeliaSim 虛擬場景中的機械轉盤 計分器 3D 列印實體化。我們利用 zmqRemoteAPI 當作 CoppeliaSim 與 Arduino 連接的橋樑。主要過程是透過 zmqRemoteAPI 接收來自 CoppeliaSim 模擬環境的訊號，並根據收到的訊號向連接的 Arduino 發 送不同的指令。再根據不同的指令控制步進馬達讓虛擬場景中的計時 器與實體計分器同步運作，從而達到虛實整合。 \n \n \n', 'tags': '', 'url': '專題摘要.html'}, {'title': 'CoppeliaSim-1', 'text': 'C o p p e l i a S i m \xa0 是 一 款 功 能 強 大 的 開 源 機 器 人 模 擬 軟 體 ， 廣 泛 應 用 於 機 器 人 研 究 、 教 育 和 工 業 領 域 。 它 提 供 了 一 個 逼 真 的 虛 擬 環 境 ， 讓 使 用 者 可 以 建 立 、 控 制 和 測 試 機 器 人 系 統 ， 而 無 需 昂 貴 的 真 實 硬 件 。 \n C o p p e l i a S i m \xa0 的 主 要 特 點 ： \n \n \n 逼 真 的 物 理 引 擎 ： \xa0 使 用 \xa0 B u l l e t \xa0 物 理 引 擎 ， 可 以 模 擬 機 器 人 的 運 動 、 碰 撞 和 與 環 境 的 交 互 。 \n \n \n 豐 富 的 圖 形 介 面 ： \xa0 提 供 直 觀 的 使 用 者 介 面 ， 用 於 建 立 和 控 制 虛 擬 環 境 和 機 器 人 模 型 。 \n \n \n 多 種 機 器 人 模 型 ： \xa0 內 置 各 種 機 器 人 模 型 ， 使 用 者 也 可 以 導 入 或 自 定 義 模 型 。 \n \n \n 可 編 程 控 制 器 ： \xa0 支 援 多 種 程 式 語 言 ， 包 括 \xa0 L u a 、 P y t h o n 、 C + + \xa0 和 \xa0 J a v a ， 讓 使 用 者 可 以 編 寫 程 式 來 控 制 機 器 人 的 行 為 。 \n \n \n 強 大 的 感 測 器 模 型 ： \xa0 提 供 各 種 感 測 器 模 型 ， 例 如 攝 影 機 、 雷 射 掃 描 器 、 觸 覺 感 測 器 和 \xa0 I M U 。 \n \n \n 網 路 連 接 ： \xa0 允 許 使 用 者 通 過 網 路 連 接 真 實 機 器 人 ， 進 行 遠 端 控 制 和 數 據 收 集 。 \n \n \n 開 源 和 免 費 ： \xa0 C o p p e l i a S i m \xa0 是 開 源 軟 體 ， 提 供 免 費 的 教 育 版 和 商 業 版 。 \n \n \n C o p p e l i a S i m \xa0 的 應 用 領 域 ： \n \n \n 機 器 人 研 究 ： \xa0 研 究 機 器 人 控 制 、 規 劃 、 導 航 、 感 知 等 方 面 。 \n \n \n 機 器 人 教 育 ： \xa0 教 學 機 器 人 技 術 、 程 式 設 計 和 系 統 設 計 。 \n \n \n 工 業 自 動 化 ： \xa0 模 擬 生 產 線 、 物 流 系 統 和 機 器 人 操 作 。 \n \n \n 遊 戲 開 發 ： \xa0 開 發 遊 戲 中 的 虛 擬 角 色 和 環 境 。 \n \n \n C o p p e l i a S i m \xa0 的 優 勢 ： \n \n \n 成 本 效 益 高 ： \xa0 無 需 昂 貴 的 真 實 機 器 人 硬 件 。 \n \n \n 安 全 性 高 ： \xa0 在 虛 擬 環 境 中 進 行 測 試 ， 避 免 潛 在 的 風 險 和 損 壞 。 \n \n \n 靈 活 性 高 ： \xa0 允 許 使 用 者 快 速 修 改 和 調 整 機 器 人 和 環 境 。 \n \n \n 可 重 複 性 高 ： \xa0 可 以 重 複 進 行 實 驗 和 測 試 ， 獲 得 一 致 的 結 果 。 \n \n \n', 'tags': '', 'url': 'CoppeliaSim-1.html'}, {'title': '機器人', 'text': '初代機器之設計 \n 第一版的機器人設計中我們先是以取球機構為重點下去進行設計，在討論過後決定做出一個類似鏟子的零件來取球，過程中不斷的去調整他的形狀及尺寸，只為了能夠更好的將球抓取及不讓它輕易滑出，經過數次的調整後，取球的方面解決了。 \n 但另外一個重點在於投籃，我們把原本的取球機構加上兩個手臂想利用向上拋的模式達到投籃的效果。但在測試後發現由於球本身的重量導致我們無法順利地將手臂抬起。 \n 在與教授討論過後得知第一版的設計主要的問題在於穩定性和精確性不足，而且也無法改調整拋球的力道和角度，所以第一版的設計可行性微乎其微。 於是我們在第一版的基礎下去改良做出了第二版的機器人。 \n \n \n \n 最終版本之機器人 \n \n 經過改良後，我們參考了類似怪手的挖土機構，將原先的Joint與支架，增加至兩組並修改了取球機構。 利用並將先前鍵盤的J、K按鈕，改為數字鍵的 (1、3)，(4、6)，(7、9)。 \n (1、3)與(4、6)的指令為兩支架的順時與逆時之轉動，(7、9)為取球機構的順時與逆時之轉動。(1、4、7)為順時，(3、6、9)為逆時。 \n 理想操作是將球鏟入後，操控兩支架，將球舉至高於籃框之高度，接近籃框後，操控取球機構向下傾斜，球便會滾入籃框並得分。 \n \n (球員尺寸範圍: 長寬高各 0.2m, 重量 5kg) \n', 'tags': '', 'url': '機器人.html'}, {'title': '圖檔-1', 'text': 'robot第一版.ttt \n robot第二版.ttt \n robot part.zip \n', 'tags': '', 'url': '圖檔-1.html'}, {'title': '程式-1', 'text': "第一版 \n from zmqRemoteApi_IPv6 import RemoteAPIClient\nimport keyboard\n\n# 创建客户端连接\nclient = RemoteAPIClient('localhost', 23000)\n\nprint('Program started')\n# 获取sim对象\nsim = client.getObject('sim')\n# 开始模拟\nsim.startSimulation()\nprint('Simulation started')\n\n# 定义设置轮子运动的函数\ndef setWheelMotion(leftSpeed, rightSpeed, up):\n    # 获取各个轮子和升降装置的对象\n    frontLeftWheel = sim.getObject('/frontLeftJoint1')\n    frontRightWheel = sim.getObject('/frontRightJoint1')\n    rearLeftWheel = sim.getObject('/rearLeftJoint1')\n    rearRightWheel = sim.getObject('/rearRightJoint1')\n    upanddown = sim.getObject('/upanddown')\n    # 设置各个轮子的目标速度\n    sim.setJointTargetVelocity(frontLeftWheel, leftSpeed)\n    sim.setJointTargetVelocity(frontRightWheel, rightSpeed)\n    sim.setJointTargetVelocity(rearLeftWheel, leftSpeed)\n    sim.setJointTargetVelocity(rearRightWheel, rightSpeed)\n    sim.setJointTargetVelocity(upanddown, up)\n\n# 初始化运动变量\nleftSpeed = 0\nrightSpeed = 0\nup = 0\n\n# 主循环\nwhile True:\n    # 检查键盘输入以设置前进和后退速度\n    if keyboard.is_pressed('w'):\n        leftSpeed = 10  # 前进\n        rightSpeed = 10  # 前进\n    elif keyboard.is_pressed('s'):\n        leftSpeed = -10  # 后退\n        rightSpeed = -10  # 后退\n    else:\n        leftSpeed = 0\n        rightSpeed = 0\n\n    # 检查键盘输入以设置转向速度\n    if keyboard.is_pressed('a'):\n        leftSpeed += 5  # 左转\n        rightSpeed -= 5  # 左转\n    elif keyboard.is_pressed('d'):\n        leftSpeed -= 5  # 右转\n        rightSpeed += 5  # 右转\n\n    # 检查键盘输入以设置升降速度\n    if keyboard.is_pressed('J'):\n        up = 10  # 上升\n    elif keyboard.is_pressed('K'):\n        up = -10  # 下降\n    else:\n        up = 0        \n\n    # 检查键盘输入以退出程序\n    if keyboard.is_pressed('q'):\n        break  # 退出\n\n    # 设置所有轮子的运动\n    setWheelMotion(leftSpeed, rightSpeed, up)\n\n# 停止模拟\nsim.stopSimulation()\n\n\n \n\n# Stop the simulation\nsim.stopSimulation()\n \n 第二版 \n from zmqRemoteApi_IPv6 import RemoteAPIClient\nimport keyboard\n\nclient = RemoteAPIClient('localhost', 23000)\n\nprint('Program started')\nsim = client.getObject('sim')\nsim.startSimulation()\nprint('Simulation started')\n\ndef setWheelMotion(leftSpeed, rightSpeed, up1, up2, up3):\n    # Set target velocity for each wheel\n    frontLeftWheel = sim.getObject('/frontLeftJoint')\n    frontRightWheel = sim.getObject('/frontRightJoint')\n    rearLeftWheel = sim.getObject('/rearLeftJoint')\n    rearRightWheel = sim.getObject('/rearRightJoint')\n    upanddown1 = sim.getObject('/upanddown1')\n    upanddown2 = sim.getObject('/upanddown2')\n    upanddown3 = sim.getObject('/upanddown3')\n    sim.setJointTargetVelocity(frontLeftWheel, leftSpeed)\n    sim.setJointTargetVelocity(frontRightWheel, rightSpeed)\n    sim.setJointTargetVelocity(rearLeftWheel, leftSpeed)\n    sim.setJointTargetVelocity(rearRightWheel, rightSpeed)\n    sim.setJointTargetVelocity(upanddown1,up1)\n    sim.setJointTargetVelocity(upanddown2,up2) \n    sim.setJointTargetVelocity(upanddown3,up3)\n# Initialize motion variables\nleftSpeed = 0\nrightSpeed = 0\nup1 = 0\nup2 = 0\nup3 = 0\n# Main loop\nwhile True:\n    # Check keyboard input\n    if keyboard.is_pressed('w'):\n        leftSpeed = 10  # Forward motion\n        rightSpeed = 10  # Forward motion\n    elif keyboard.is_pressed('s'):\n        leftSpeed = -10  # Backward motion\n        rightSpeed = -10  # Backward motion\n    else:\n        leftSpeed = 0\n        rightSpeed = 0\n\n    if keyboard.is_pressed('a'):\n        leftSpeed -= 5  # Left turn\n        rightSpeed += 5  # Left turn\n    elif keyboard.is_pressed('d'):\n        leftSpeed += 5  # Right turn\n        rightSpeed -= 5  # Right turn\n        \n    if keyboard.is_pressed('1'):\n        up1 = 1  # Forward motion\n    elif keyboard.is_pressed('3'):\n        up1 = -1  # Backward motion\n    else:\n        up1 = 0\n        \n    if keyboard.is_pressed('4'):\n        up2 = 1  # Forward motion\n    elif keyboard.is_pressed('6'):\n        up2 = -1  # Backward motion\n    else:\n        up2 = 0\n        \n    if keyboard.is_pressed('7'):\n        up3 = 1  # Forward motion\n    elif keyboard.is_pressed('9'):\n        up3 = -1  # Backward motion\n    else:\n        up3 = 0\n        \n    if keyboard.is_pressed('q'):\n        break  # Quit\n\n    # Set motion for all wheels\n    setWheelMotion(leftSpeed, rightSpeed, up1, up2, up3)\n\n# Stop the simulation\nsim.stopSimulation() \n", 'tags': '', 'url': '程式-1.html'}, {'title': '球場', 'text': '最初我們利用一條sensor當作得分感測器，由於場上會同時有10顆球，僅需將得分之球重製。一開始我們先加入另外一顆球做測試， 嘗試只將得分之球重製回初始位置。但後來發現 不管哪顆球觸碰到sensor後，兩顆球都會同時回到初始位置。  \n 後續我們建立第二版之測試， 我們將sensor新增至兩條，分別獨立對應得分之球，並希望能將對應之球得分後回到初始位置，但嘗試了幾次，且重複確認程式有無錯誤，還是無法達成預期效果，所以打算放棄sensor，並不斷找尋另一種方法。 \n  最終版本：我們打算利用物體碰撞之效果取代先前的sensor，當作另一種感測器，發現這種方法非常之順利，並達成了預期效果， 改良後我們在 足球門和籃框裡加入碰撞塊當作新一代感測器 ，並關閉其可見性以免阻擋視線，當球觸碰到碰撞塊後，不僅會得分，還能連同將得分之球重製回初始位置，其餘之球一樣在場上作動。我們就將此方法利用在足球門與籃框上，達成目的。 \n \n 進足球門得1分(計分器旋轉36度) \n 進籃框得5分(計分器旋轉180度) \n \n 場地: 長 4m x 寬 2.5m, 外圍以足夠高度之隱形柵欄區隔 \n 競技球: 白色, 直徑 0.1m, 重量 0.5kg \n 籃板: 長 0.3m, 高 0.3m, 寬 0.1m, 位於足球門上方中央 \n 籃框: 由籃板向場內距離 0.1m, 內徑 0.2m, 框管直徑 0.02 \n 足球門: 長 0.6m, 高 0.3m, 寬 0.1m \n', 'tags': '', 'url': '球場.html'}, {'title': '籃框程式', 'text': "function sysCall_init()\n    wheelJoint = sim.getObjectHandle('/joint1g')\n    rim1 = sim.getObject('/Cylinder1') \n    ball1 = sim.getObject('/ball1')\n    ball2 = sim.getObject('/ball2')\n    ball3 = sim.getObject('/ball3')\n    ball4 = sim.getObject('/ball4')\n    ball5 = sim.getObject('/ball5')\n    ball6 = sim.getObject('/ball6')\n    ball7 = sim.getObject('/ball7')\n    ball8 = sim.getObject('/ball8')\n    ball9 = sim.getObject('/ball9')\n    ball10 = sim.getObject('/ball10')\n\nend\n\nfunction sysCall_actuation()\n    collision1= sim.checkCollision(ball1,rim1)\n    collision2= sim.checkCollision(ball2,rim1)\n    collision3= sim.checkCollision(ball3,rim1)\n    collision4= sim.checkCollision(ball4,rim1)\n    collision5= sim.checkCollision(ball5,rim1)\n    collision6= sim.checkCollision(ball6,rim1)\n    collision7= sim.checkCollision(ball7,rim1)\n    collision8= sim.checkCollision(ball8,rim1)\n    collision9= sim.checkCollision(ball9,rim1)\n    collision10= sim.checkCollision(ball10,rim1)\n    if ( collision1 > 0) then\n        sim.setObjectPosition(ball1, -1, {0,0,0.25})\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-180)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision2 > 0) then\n        sim.setObjectPosition(ball2, -1, {0,0,0.25})\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-180)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision3 > 0) then\n        sim.setObjectPosition(ball3, -1, {0,0,0.25})\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-180)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision4 > 0) then\n        sim.setObjectPosition(ball4, -1, {0,0,0.25})\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-180)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision5 > 0) then\n        sim.setObjectPosition(ball5, -1, {0,0,0.25})\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-180)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision6 > 0) then\n        sim.setObjectPosition(ball6, -1, {0,0,0.25})\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-180)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision7 > 0) then\n        sim.setObjectPosition(ball7, -1, {0,0,0.25})\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-180)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision8 > 0) then\n        sim.setObjectPosition(ball8, -1, {0,0,0.25})\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-180)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision9 > 0) then\n        sim.setObjectPosition(ball9, -1, {0,0,0.25})\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-180)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision10 > 0) then\n        sim.setObjectPosition(ball10, -1, {0,0,0.25})\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-180)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n             end\n            end\n           end\n          end\n         end\n        end\n      end\n     end\n    end  \n  end\nend \n \n", 'tags': '', 'url': '籃框程式.html'}, {'title': '足球門程式', 'text': "第一版 \n function sysCall_init()\n    score = 0\n    wheelJoint = sim.getObjectHandle('/joint1g')\n    robot = {\n        sim.getObjectHandle('/basic'),\n    }\n    initialPos = {\n        {-1.050, -0.77134, 0.21},\n        {-1.050, -0.27134, 0.21},\n        {-1.050, 0.22867, 0.21},\n        {-1.050, 0.62866, 0.21},\n    }\n    initialOri = {\n        {90, 90, 0},\n    }\n\nend\n\nsensor = sim.getObject('./sensor')\ninitialPosBall = sim.getObjectPosition(sensor, -1)\nball = sim.getObject('/ball')\n\nfunction sysCall_actuation()\n    result = sim.readProximitySensor(sensor)\n    if (result > 0) then\n        score = score + 1\n        sim.setObjectPosition(ball, -1, {0,0,0.25})\n        \n        -- Rotate the wheel joint by 36 degrees\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-36)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n        \n        for i = 1, 8 do\n            sim.setObjectPosition(robot[i], -1, initialPos[i])\n            sim.setObjectOrientation(robot[i], -1, initialOri[i])\n        end\nend\n\nfunction sysCall_cleanup()\n    sim.setShapeColor(goalHandle, nil, sim.colorcomponent_ambient_diffuse,{0, 0, 0}) \n 第二版 \n function sysCall_init()\n    score = 0\n    wheelJoint = sim.getObjectHandle('/joint1g')\n    robot = {\n        sim.getObjectHandle('/basic'),\n    }\n    initialPos = {\n        {-1.050, -0.77134, 0.21},\n        {-1.050, -0.27134, 0.21},\n        {-1.050, 0.22867, 0.21},\n        {-1.050, 0.62866, 0.21},\n    }\n    initialOri = {\n        {90, 90, 0},\n    }\n\n    sensor1 = sim.getObject('/sensor1') -- 第一个传感器\n    sensor2 = sim.getObject('/sensor2') -- 第二个传感器\n\n    ball1 = sim.getObject('/ball1')\n    ball2 = sim.getObject('/ball2')\nend\n\nfunction sysCall_actuation()\n    result1 = sim.readProximitySensor(sensor1)\n    result2 = sim.readProximitySensor(sensor2)\n    \n    if (result1 > 0 or result2 > 0) then\n        score = score + 1\n        sim.setObjectPosition(ball1, -1, {0,0,0.25})\n        sim.setObjectPosition(ball2, -1, {0,10,0.25})\n        \n        -- Rotate the wheel joint by 36 degrees\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-36)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n        \n\n        -- Rotate the wheel joint by 36 degrees\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-36)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n        \n        for i = 1, 8 do\n\n        end\n        \n        goalEffectEnabled = true\n        lastGoalPlayer = result1 or result2\n        flashingState = false\n        flashingTimer = 0\n end\n    \n\nfunction sysCall_cleanup()\n    sim.setShapeColor(goalHandle, nil, sim.colorcomponent_ambient_diffuse,{0, 0, 0})\nend\n \n 最終版 \n function sysCall_init()\n    wheelJoint = sim.getObjectHandle('/joint1g')\n    door1 = sim.getObject('/Cuboid') \n    ball1 = sim.getObject('/ball1')\n    ball2 = sim.getObject('/ball2')\n    ball3 = sim.getObject('/ball3')\n    ball4 = sim.getObject('/ball4')\n    ball5 = sim.getObject('/ball5')\n    ball6 = sim.getObject('/ball6')\n    ball7 = sim.getObject('/ball7')\n    ball8 = sim.getObject('/ball8')\n    ball9 = sim.getObject('/ball9')\n    ball10 = sim.getObject('/ball10')\n\nend\n\nfunction sysCall_actuation()\n    collision1= sim.checkCollision(ball1,door1)\n    collision2= sim.checkCollision(ball2,door1)\n    collision3= sim.checkCollision(ball3,door1)\n    collision4= sim.checkCollision(ball4,door1)\n    collision5= sim.checkCollision(ball5,door1)\n    collision6= sim.checkCollision(ball6,door1)\n    collision7= sim.checkCollision(ball7,door1)\n    collision8= sim.checkCollision(ball8,door1)\n    collision9= sim.checkCollision(ball9,door1)\n    collision10= sim.checkCollision(ball10,door1)\n    if ( collision1 > 0) then\n        sim.setObjectPosition(ball1, -1, {0,0,0.25})\n        -- Rotate the wheel joint by 36 degrees\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-36)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision2 > 0) then\n        sim.setObjectPosition(ball2, -1, {0,0,0.25})\n        -- Rotate the wheel joint by 36 degrees\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-36)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision3 > 0) then\n        sim.setObjectPosition(ball3, -1, {0,0,0.25})\n        -- Rotate the wheel joint by 36 degrees\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-36)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision4 > 0) then\n        sim.setObjectPosition(ball4, -1, {0,0,0.25})\n        -- Rotate the wheel joint by 36 degrees\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-36)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision5 > 0) then\n        sim.setObjectPosition(ball5, -1, {0,0,0.25})\n        -- Rotate the wheel joint by 36 degrees\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-36)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision6 > 0) then\n        sim.setObjectPosition(ball6, -1, {0,0,0.25})\n        -- Rotate the wheel joint by 36 degrees\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-36)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision7 > 0) then\n        sim.setObjectPosition(ball7, -1, {0,0,0.25})\n        -- Rotate the wheel joint by 36 degrees\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-36)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision8 > 0) then\n        sim.setObjectPosition(ball8, -1, {0,0,0.25})\n        -- Rotate the wheel joint by 36 degrees\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-36)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision9 > 0) then\n        sim.setObjectPosition(ball9, -1, {0,0,0.25})\n        -- Rotate the wheel joint by 36 degrees\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-36)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision10 > 0) then\n        sim.setObjectPosition(ball10, -1, {0,0,0.25})\n        -- Rotate the wheel joint by 36 degrees\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-36)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n             end\n            end\n           end\n          end\n         end\n        end\n      end\n     end\n    end  \n  end\nend \n \n", 'tags': '', 'url': '足球門程式.html'}, {'title': '機械轉盤計分器', 'text': '得分時個位數轉盤會旋轉(36度or180度) \n 當個位數轉盤旋轉一圈後(數字9to數字0)，會帶動下方小齒輪並驅使十位數轉盤旋轉36度，依此類推。 \n (一分為個位數轉盤36度) \n \n \n', 'tags': '', 'url': '機械轉盤計分器.html'}, {'title': '圖檔-2', 'text': '機械記分板與零件.zip \n', 'tags': '', 'url': '圖檔-2.html'}, {'title': '3D列印之實體計分器', 'text': '\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0個位數轉盤\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0十位數轉盤 \n \xa0 \xa0 \xa0 \n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 連接齒輪\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0支架 \n \xa0 \n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 機械轉盤計分器實體 \n \n \n', 'tags': '', 'url': '3D列印之實體計分器.html'}, {'title': 'Arduino-1', 'text': '為了實現虛實整合，我們理想狀況是利用Arduino配合步進馬達來驅動實體機械轉盤計分器。由於不確定此方法的可行性，我們進行了第一版測試，先使用實體按鈕來觸發轉動，每按一次按鈕，馬達旋轉36度，並測試是否能成功帶動轉盤。 \n \n 先將步進馬達與解碼器配合 \n \n \xa0 \n \xa0 \xa0 \xa0 2.再將步進馬達解碼器與按鈕如下圖接至arduino開發板之對應腳位。 \n \xa0\xa0 \n 步進馬達第一版測試 \n #include <Stepper.h> \n\nStepper stepper(100, 11, 10, 9, 8); // 初始化步進馬達，步數為100，使用引腳11, 10, 9, 8\n#define but1 2 // 定義按鈕接在引腳2上\n\nlong currentPosition = 0; // 變數來記錄當前位置\n\nvoid setup() \n{\n  pinMode(but1, INPUT);  // 設置引腳2為輸入\n  stepper.setSpeed(80);  // 設置馬達速度為100 RPM\n  Serial.begin(115200);   // 初始化串口通信，波特率設置為115200\n}\n\nvoid loop() \n{\n  // 檢查按鈕是否被按下\n  if (digitalRead(but1) == HIGH)\n  {\n    stepper.step(50); // 正轉200步（36度）\n    currentPosition += 200; // 更新當前位置\n    delay(500);\n  } \n 經過這次測試，確定了步進馬達帶動轉盤並正確旋轉36度此方法的可行性。並以此為基礎來實現虛擬場景與實體計分器之整合。 \n \n \n', 'tags': '', 'url': 'Arduino-1.html'}, {'title': '電子計時器', 'text': '當遊戲開始時，電子計時器從10分鐘開始倒數，歸零時便會結束本場遊戲。 \n \n', 'tags': '', 'url': '電子計時器.html'}, {'title': '程式-2', 'text': "function sysCall_init()\n    t2=0\n    s0={1,1,1,0,1,1,1}\n    s1={0,0,1,0,0,1,0}\n    s2={1,0,1,1,1,0,1}\n    s3={1,0,1,1,0,1,1}\n    s4={0,1,1,1,0,1,0}\n    s5={1,1,0,1,0,1,1}\n    s6={1,1,0,1,1,1,1}\n    s7={1,0,1,0,0,1,0}\n    s8={1,1,1,1,1,1,1}\n    s9={1,1,1,1,0,1,1}\n    s={s0,s1,s2,s3,s4,s5,s6,s7,s8,s9}\n    \n    score(0,'a')\n    score(0,'b')\n    score(0,'c')\n    score(0,'d')\nend\n\nfunction score(x,y)\n    for i=0 ,9,1 do\n        if (x==i)then\n            for j = 0,6,1 do\n                local part = sim.getObject('./'..y..''..j..'')\n                if (s[i+1][j+1]==1) then\n                    sim.setShapeColor(part, nil, sim.colorcomponent_ambient_diffuse, {1, 0, 0})\n                else\n                    sim.setShapeColor(part, nil, sim.colorcomponent_ambient_diffuse, {0, 0, 0})\n                end\n            end\n        end\n    end\nend\n\nfunction sysCall_actuation()\n    \n    simulationTime = sim.getSimulationTime()\n    simulationTime1=600-simulationTime/3\n\n    t1=math.floor((simulationTime1/600)%10)\n    score(t1,'a')\n    t2=math.floor((simulationTime1/60)%10)\n    score(t2,'b')\n    t3=math.floor((simulationTime1/10)%6)\n    score(t3,'c')\n    t4=math.floor(simulationTime1%10)\n    score(t4,'d')\n    \n    if (simulationTime1<1)then\n        sim.pauseSimulation()\n    end\n    \n    p=sim.getSimulationState()\n    if(p==22)then\n        score(0,'a')\n        score(0,'b')\n        score(0,'c')\n        score(0,'d')\n    end\n        \n    \nend \n", 'tags': '', 'url': '程式-2.html'}, {'title': '協同設定', 'text': '', 'tags': '', 'url': '協同設定.html'}, {'title': '遊戲連線說明', 'text': '1.將防火牆都關閉 \n \n 2.設定特定連接埠並選擇以系統管理員身分執行 \n \n 3.設定IPV6位址 \n \n 4.開啟zmq以及CoppeliaSim(4.5.1) \n \n 5.將Localhost改為組長的IPV6位址 \n \n 6.在瀏覽器輸入http://[組長IP]:23020\xa0 即可觀看場景並連線對戰 \n \n', 'tags': '', 'url': '遊戲連線說明.html'}, {'title': '程式聯動', 'text': '在CoppeliaSim裡，我們在籃框與足球門中加入了碰撞塊當作感測器，發生碰撞時就會觸發得分程式。在開始模擬時CoppeliaSim會持續向RemoteAPI發送碰撞訊號，當碰撞訊號發生改變時，RemoteAPI會透過連接埠(COM5)向Arduino發送1或2的訊號，在Arduino接收到訊號1時，馬達便會帶動實體計分器旋轉36度；收到訊號2時，旋轉180度。 \n', 'tags': '', 'url': '程式聯動.html'}, {'title': 'CoppeliaSim-2', 'text': '此程式主要透過碰撞塊當作感測器來觸發得分程式，並將分別的碰撞訊號送至RemoteAPI。 \n \n 足球門之程式\xa0 \n \n balls = {}\nmessageSent = false\n\nfunction sysCall_init()\n    wheelJoint = sim.getObjectHandle(\'/joint1g\')\n    door1 = sim.getObject(\'/Cuboid\') \n    \n    for i = 1, 10 do\n        balls[i] = sim.getObject(\'/ball\' .. i)\n    end\nend\n\nfunction sysCall_actuation()\n    for i = 1, 10 do\n        local collision = sim.checkCollision(balls[i], door1)\n        if collision > 0 and not messageSent then\n            sim.setObjectPosition(balls[i], -1, {0,0,0.25})\n            -- Rotate the wheel joint by 36 degrees\n            local currentAngle = sim.getJointPosition(wheelJoint)\n            local targetAngle = currentAngle + math.rad(-36)\n            sim.setJointTargetPosition(wheelJoint, targetAngle)\n            local startTime = os.clock()\n            while os.clock() - startTime < 0.01 do\n            end\n            sim.setStringSignal("message", "1")  -- ?? "5" ??\n            messageSent = true  -- ??????????????\n            return\n        end\n    end\n    -- ????????? messageSent ? false\n    if messageSent then\n        sim.setStringSignal("message", "5") \n        messageSent = false\n    end\nend \n \n 籃框之程式 \n \n balls = {}\nmessageSent = false\n\nfunction sysCall_init()\n    wheelJoint = sim.getObjectHandle(\'/joint1g\')\n    rim1 = sim.getObject(\'/Cylinder1\') \n    \n    for i = 1, 10 do\n        balls[i] = sim.getObject(\'/ball\' .. i)\n    end\nend\n\nfunction sysCall_actuation()\n    for i = 1, 10 do\n        local collision = sim.checkCollision(balls[i], rim1)\n        if collision > 0 and not messageSent then\n            sim.setObjectPosition(balls[i], -1, {0,0,0.25})\n            -- Rotate the wheel joint by 36 degrees\n            local currentAngle = sim.getJointPosition(wheelJoint)\n            local targetAngle = currentAngle + math.rad(-179.999)\n            sim.setJointTargetPosition(wheelJoint, targetAngle)\n            local startTime = os.clock()\n            while os.clock() - startTime < 0.1 do\n            end\n            sim.setStringSignal("message", "2") \n            messageSent = true\n            return \n        end\n    end\n    if messageSent then\n        sim.setStringSignal("message", "5") \n        messageSent = false\n    end\nend \n', 'tags': '', 'url': 'CoppeliaSim-2.html'}, {'title': 'RemoteAPI', 'text': '此段程式用於接收來自CoppeliaSim模擬環境的訊號，並根據收到的訊號向連接的Arduino發送不同的指令。 \n \n from zmqRemoteApi_IPv6 import RemoteAPIClient\nimport serial\nimport time\n\nclient = RemoteAPIClient(\'localhost\', 23000)\narduino = serial.Serial(port=\'COM5\', baudrate=115200, timeout=.1)\nprint(\'Program started\')\n\nsim = client.getObject(\'sim\')\nsim.startSimulation()\nprint(\'Simulation started\')\n\ndef write_read(x):\n    arduino.write(bytes(x, \'utf-8\'))\n    time.sleep(0.05)\n    data = arduino.readline()\n    return data\nwhile True:\n    message = sim.getStringSignal("message")\n    print(message)\n    if message is not None:\n        try:\n            message_int = int(message)\n            if message_int == 1:\n                print("Rotation event detected! Sending signal \'1\' to Arduino.")\n                response = write_read(\'1\') \n            if message_int == 2:\n                print("Rotation event detected! Sending signal \'1\' to Arduino.")\n                response = write_read(\'2\')  \n        except ValueError:\n            print("Invalid message received from simulation.")\n    else:\n        print("Failed to get message from simulation.")\n \n \n', 'tags': '', 'url': 'RemoteAPI.html'}, {'title': 'Arduino-2', 'text': "\n 這段程式用於控制步進馬達以及接收來自串口的指令以執行不同的動作。 \n \n #include <Stepper.h> \n\nStepper stepper(100, 11, 10, 9, 8); // 初始化步進馬達，步數為100，使用引腳11, 10, 9, 8\n#define but1 2 // 定義按鈕接在引腳2上\n\nlong currentPosition = 0; // 變數來記錄當前位置\n\nvoid setup() \n{\n  pinMode(but1, INPUT);  // 設置引腳2為輸入\n  stepper.setSpeed(80);  // 設置馬達速度為100 RPM\n  Serial.begin(115200);   // 初始化串口通信，波特率設置為115200\n}\n\nvoid loop() \n{\n  // 檢查按鈕是否被按下\n  if (digitalRead(but1) == HIGH)\n  {\n    stepper.step(50); // 正轉200步（36度）\n    currentPosition += 200; // 更新當前位置\n    delay(500);\n  }\n\n  // 檢查是否有來自串口的數據\n  if (Serial.available() > 0)\n  {\n    char received = Serial.read();  // 讀取一個字節的數據\n    if (received == '1')\n    {\n      stepper.step(200); // 收到信號'1'後正轉200步（36度）\n      currentPosition += 200; // 更新當前位置\n      delay(500);\n    }\n    if (received == '2')\n    {\n      stepper.step(1000); // 收到信號'2'後正轉1000步（180度）\n      currentPosition += 1000; // 更新當前位置\n      delay(500);\n    }\n    if (received == '0')\n    {\n      // 計算回到初始位置所需的步數\n      long stepsToReturn = -currentPosition;\n      stepper.step(stepsToReturn); // 移動回初始位置\n      currentPosition = 0; // 重置當前位置\n      delay(500);\n    }\n  }\n}\n \n", 'tags': '', 'url': 'Arduino-2.html'}, {'title': '倉儲維護', 'text': '\n 建立 \xa0 Replit \xa0 帳號 \n 登入 Email 驗證 \xa0 Replit \xa0 寄出的註冊確認電子郵件 \n 利用 import repository, 以 \xa0 cmsite \xa0 倉儲內容, 建立 repl \n 進入 .replit 檔案設定頁面, 將 main.py 設定為啟動程式 \n 在 shell 介面執行 git submodule update --init --recursive, 取下 \xa0 cmsite \xa0 倉儲中 cmsimde 子模組檔案 \n 在 shell 介面執行 pip install flask flask_cors bs4 lxml pelican markdown gevent, 安裝 cmsimde 所需要的模組 \n 按下 Run, 啟動 main.py \n 登入 \xa0 cmsite \xa0 動態網站, 修改管理者密碼, 修改標題與內容後, 以 generate_pages 將動態網頁內容轉為靜態格式 \n 利用 \xa0 Replit \xa0 中的 Version Control 功能, 將改版資料推向遠端倉儲 \n \n', 'tags': '', 'url': '倉儲維護.html'}, {'title': '最終成品展示', 'text': '\n', 'tags': '', 'url': '最終成品展示.html'}, {'title': '影片展示', 'text': '機械記分板 虛實結合 \n 機械記分板 虛實結合+機器人控制 \n', 'tags': '', 'url': '影片展示.html'}, {'title': '檔案', 'text': '操作程式.7z \n 遊戲最終成品 \n', 'tags': '', 'url': '檔案.html'}, {'title': '專題論文', 'text': '初版專題論文.zip \n 正式版專題.zip \n', 'tags': '', 'url': '專題論文.html'}, {'title': 'References', 'text': '\n \xa0 \xa0 \xa0 \xa0\xa0 https://github.com/mdecd2024/test-ag1 \n https://github.com/mdecd2023/2a3-pj3ag4 \n https://projecthub.arduino.cc/ansh2919/serial-communication-between-python-and-arduino-663756 \n https://manual.coppeliarobotics.com/en/regularApi/simGetStringSignal.htm \n \xa0 \xa0 \xa0 \xa0  https://manual.coppeliarobotics.com/en/regularApi/simSetStringSignal.htm \n \xa0 \xa0 \xa0 \xa0 https://m.bilibili.com/video/BV1qH4y1Q7Wv?\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0spm_id_from=333.788.recommend_more_video.9 \n \xa0 \xa0 \xa0 \xa0 https://forum.coppeliarobotics.com/viewtopic.php?t=9533 \n \xa0 \xa0 \xa0 \xa0 https://forum.arduino.cc/t/maze-solving-robot-with-coppeliasim/1199185 \n \xa0 \xa0 \xa0 \xa0Conveyor Belt Speed Control Through CAN BUS in CoppeliaSim using Arduino Mega2560 \n \n soccer field image from\xa0 public domain . \n', 'tags': '', 'url': 'References.html'}, {'title': 'Score_counter', 'text': '機械轉盤計分器: \n 原始設計: \n \n 以 SolidWorks 設計繪圖:  scoreboard_solidworks_cd2023_pj3ag4.7z  (由  cd2023 pj3 2a 第四組 完成設計繪圖) \n 本專題將修改設計後納入步進馬達控制轉角, 並利用 Python 程式與 CoppeliaSim 場景伺服器賽局計分器同步作動. \n \n', 'tags': '', 'url': 'Score_counter.html'}, {'title': 'Brython', 'text': 'cmsite: wcms use  https://github.com/mdecycu/cmsimde  as submodule \n https://en.wikipedia.org/wiki/Python_(programming_language) \n Examples: \n https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d \n https://www.geeksforgeeks.org/python-programming-examples/ \n https://www.programiz.com/python-programming/examples \n https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/ \n Python Tutorial: \n https://docs.python.org/3/tutorial/ \n An informal introduction to Python \n Indentation \n Variables \n Comments \n Numbers \n Strings \n print \n Python control flow tools \n for \n if \n range \n open \n read \n lists \n tuples \n dictionaries \n functions \n try ... except \n break \n pass \n classes \n 這個頁面 demo 如何在同一頁面下納入多個線上 Ace 編輯器與執行按鈕 ( practice_html.txt  動態頁面超文件). \n practice_html.txt  動態頁面超文件應該可以在啟動 Brython 時, 設定將 .py 檔案放入 downloads/py 目錄中引用. \n 亦即將所有對應的 html 也使用 Brython 產生, 然後寫為  class  後, 在範例導入時透過  instance  引用. \n <!-- 啟動 Brython -->\n<script>\nwindow.onload=function(){\nbrython({debug:1, pythonpath:[\'./../cmsimde/static/\',\'./../downloads/py/\']});\n}\n</script> \n 從 1 累加到 100: \n 1 add to 100 \n 將 iterable 與 iterator  相關說明 , 利用 Brython 與 Ace Editor 整理在這個頁面. \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n', 'tags': '', 'url': 'Brython.html'}]};