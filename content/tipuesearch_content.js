var tipuesearch = {"pages": [{'title': 'About', 'text': '專題題目： 網際球賽機器人協同設計與模擬 \n Web-based Ball Game Robot Collaborative Design and Simulation \n \n 專題網站:  https://mde.tw/pj4102 \n 專題倉儲:  https://github.com/mdecycu/pj4102 \n 專題成員: \n 41023220 陳冠珉 \n 41023230 彭聖宗 \n 41023231 湛有杰  https://github.com/zhan-uj/pj4102 \n 41023232 雲敬家 \n 41071203 侯昀熙 \n \n 網際球賽機器人協同設計與模擬 \n 球賽設計: \n 每場競技時間為 10 分鐘 \n 每隊球員機器人依照各組人數平均分為兩隊 \n 雙方陣營各有足球門與籃球框各一具 \n 球場中由裁判程式於開場時, 在球場正中央落下 10 球 \n 將球踢進對方球門者得 1 分, 將球投入對方籃框者得 5 分 \n', 'tags': '', 'url': 'About.html'}, {'title': '遊戲設計與改版', 'text': '\n 網 際 球 賽 機 器 人 協 同 設 計 與 模 擬與 虛 實 整 合 \n 本 專 題 以 「 網 際 球 賽 機 器 人 協 同 設 計 與 模 擬 」 為 主 題 ， 旨 在 利 用 科 技 創 造 出 互 動 性 強 的 機 器 人 運 動 遊 戲 ， 並 探 索 虛 實 整 合 的 可 能 性 。 專 案 初 期 ， 我 們 運 用   A u t o d e s k   I n v e n t o r   軟 體 設 計 了 機 器 人 球 員 模 型 ， 並 將 其 導 入   C o p p e l i a S i m   虛 擬 環 境 中 。 這 個 虛 擬 場 景 包 含 了 完 整 的 球 賽 元 素 ， 例 如 足 球 、 球 場 、 球 門 、 籃 板 、 籃 框 、 記 分 板 和 計 時 器 ， 為 機 器 人 比 賽 提 供 了 逼 真 的 環 境 。 \n 為 了 實 現 協 同 設 計 ， 我 們 採 用   P y t h o n   z mq R e m o t e A P I   程 式 技 術 來 控 制 機 器 人 動 作 並 開 發 得 分 程 式 。 透 過 網 路 連 線 ， 四 名 玩 家 可 以 在 各 自 的 電 腦 上 操 控 機 器 人 球 員 ， 參 與 虛 擬 球 賽 。 此 設 計 讓 玩 家 可 以 透 過 協 作 ， 共 同 體 驗 機 器 人 運 動 的 樂 趣 。 \n 專 題 的 核 心 目 標 之 一 是 實 現 虛 實 整 合 。 我 們 將   C o p p e l i a S i m   虛 擬 場 景 中 的 機 械 轉 盤記分板 實 體 化 ， 使 用   3 D   列 印 技 術 製 作 等 比 例 的 實 體 轉 盤記分板 。 同 時 ， 我 們 將 遊 戲 中 的 得 分 程 式 移 植 到   A r d u i n o   平 台 ， 利 用   A r d u i n o   控 制 伺 服 馬 達 ， 實 現 實 體 轉 盤記分板 的 運 作 。 最 後 ， 我 們 將 利 用   U S B   將   C o p p e l i a S i m   中 的 得 分 指 令 傳 輸 至   A r d u i n o ， 讓 虛 擬 場 景 中 的記分板 與 實 體記分板 同 步 運 作 。 \n 虛 實 整 合 \xa0 : \xa0 將 虛 擬 世界 和 現 實 世 界 緊 密 結 合 ， 創 造 出 更 豐 富 、 更 具 互 動 性 的 體 驗 。 它 就 像 一 座 橋 樑 ， 將 虛 擬 的 資 訊 和 功 能 與 真 實 的 環 境 和 事 物 聯 繫 起 來 ， 讓 使 用 者 可 以 在 真 實 世 界 中 體 驗 到 虛 擬 世 界 的 優 勢 。 \n \n \n', 'tags': '', 'url': '遊戲設計與改版.html'}, {'title': 'CoppeliaSim', 'text': 'C o p p e l i a S i m \xa0 是 一 款 功 能 強 大 的 開 源 機 器 人 模 擬 軟 體 ， 廣 泛 應 用 於 機 器 人 研 究 、 教 育 和 工 業 領 域 。 它 提 供 了 一 個 逼 真 的 虛 擬 環 境 ， 讓 使 用 者 可 以 建 立 、 控 制 和 測 試 機 器 人 系 統 ， 而 無 需 昂 貴 的 真 實 硬 件 。 \n C o p p e l i a S i m \xa0 的 主 要 特 點 ： \n \n \n 逼 真 的 物 理 引 擎 ： \xa0 使 用 \xa0 B u l l e t \xa0 物 理 引 擎 ， 可 以 模 擬 機 器 人 的 運 動 、 碰 撞 和 與 環 境 的 交 互 。 \n \n \n 豐 富 的 圖 形 介 面 ： \xa0 提 供 直 觀 的 使 用 者 介 面 ， 用 於 建 立 和 控 制 虛 擬 環 境 和 機 器 人 模 型 。 \n \n \n 多 種 機 器 人 模 型 ： \xa0 內 置 各 種 機 器 人 模 型 ， 使 用 者 也 可 以 導 入 或 自 定 義 模 型 。 \n \n \n 可 編 程 控 制 器 ： \xa0 支 援 多 種 程 式 語 言 ， 包 括 \xa0 L u a 、 P y t h o n 、 C + + \xa0 和 \xa0 J a v a ， 讓 使 用 者 可 以 編 寫 程 式 來 控 制 機 器 人 的 行 為 。 \n \n \n 強 大 的 感 測 器 模 型 ： \xa0 提 供 各 種 感 測 器 模 型 ， 例 如 攝 影 機 、 雷 射 掃 描 器 、 觸 覺 感 測 器 和 \xa0 I M U 。 \n \n \n 網 路 連 接 ： \xa0 允 許 使 用 者 通 過 網 路 連 接 真 實 機 器 人 ， 進 行 遠 端 控 制 和 數 據 收 集 。 \n \n \n 開 源 和 免 費 ： \xa0 C o p p e l i a S i m \xa0 是 開 源 軟 體 ， 提 供 免 費 的 教 育 版 和 商 業 版 。 \n \n \n C o p p e l i a S i m \xa0 的 應 用 領 域 ： \n \n \n 機 器 人 研 究 ： \xa0 研 究 機 器 人 控 制 、 規 劃 、 導 航 、 感 知 等 方 面 。 \n \n \n 機 器 人 教 育 ： \xa0 教 學 機 器 人 技 術 、 程 式 設 計 和 系 統 設 計 。 \n \n \n 工 業 自 動 化 ： \xa0 模 擬 生 產 線 、 物 流 系 統 和 機 器 人 操 作 。 \n \n \n 遊 戲 開 發 ： \xa0 開 發 遊 戲 中 的 虛 擬 角 色 和 環 境 。 \n \n \n C o p p e l i a S i m \xa0 的 優 勢 ： \n \n \n 成 本 效 益 高 ： \xa0 無 需 昂 貴 的 真 實 機 器 人 硬 件 。 \n \n \n 安 全 性 高 ： \xa0 在 虛 擬 環 境 中 進 行 測 試 ， 避 免 潛 在 的 風 險 和 損 壞 。 \n \n \n 靈 活 性 高 ： \xa0 允 許 使 用 者 快 速 修 改 和 調 整 機 器 人 和 環 境 。 \n \n \n 可 重 複 性 高 ： \xa0 可 以 重 複 進 行 實 驗 和 測 試 ， 獲 得 一 致 的 結 果 。 \n \n \n', 'tags': '', 'url': 'CoppeliaSim.html'}, {'title': '機器人', 'text': '初代機器之設計 \n 初代版本原本想利用我們所繪製的取球鏟子將球鏟入其中，並利用鍵盤J、K按鈕來控制Joint進行鏟子之順時與逆時轉動，去帶動球，往切線方向射出，並進行投籃動作。 \n \n 在後續測試與教授討論後，發現這種鏟子的設計能讓球順利投進籃框的機率微乎其微，所以在後來組員們進行不斷的討論與改良取球機構，而製作出下一個版本的取球機構。 \n \n 最終版本之機器人 \n \n 經過改良後，我們參考了類似怪手的挖土機構，將原先的Joint與支架，增加至兩組並修改了取球機構。 利用並將先前鍵盤的J、K按鈕，改為數字鍵的 (1、3)，(4、6)，(7、9)。 \n (1、3)與(4、6)的指令為兩支架的順時與逆時之轉動，(7、9)為取球機構的順時與逆時之轉動。(1、4、7)為順時，(3、6、9)為逆時。 \n 理想操作是將球鏟入後，操控兩支架，將球舉至高於籃框之高度，接近籃框後，操控取球機構向下傾斜，球便會滾入籃框並得分。 \n \n (球員尺寸範圍: 長寬高各 0.2m, 重量 5kg) \n', 'tags': '', 'url': '機器人.html'}, {'title': '圖檔-1', 'text': 'robot第一版.ttt \n robot第二版.ttt \n robot part.zip \n', 'tags': '', 'url': '圖檔-1.html'}, {'title': '程式-1', 'text': "第一版 \n from zmqRemoteApi_IPv6 import RemoteAPIClient\nimport keyboard\n\n# 创建客户端连接\nclient = RemoteAPIClient('localhost', 23000)\n\nprint('Program started')\n# 获取sim对象\nsim = client.getObject('sim')\n# 开始模拟\nsim.startSimulation()\nprint('Simulation started')\n\n# 定义设置轮子运动的函数\ndef setWheelMotion(leftSpeed, rightSpeed, up):\n    # 获取各个轮子和升降装置的对象\n    frontLeftWheel = sim.getObject('/frontLeftJoint1')\n    frontRightWheel = sim.getObject('/frontRightJoint1')\n    rearLeftWheel = sim.getObject('/rearLeftJoint1')\n    rearRightWheel = sim.getObject('/rearRightJoint1')\n    upanddown = sim.getObject('/upanddown')\n    # 设置各个轮子的目标速度\n    sim.setJointTargetVelocity(frontLeftWheel, leftSpeed)\n    sim.setJointTargetVelocity(frontRightWheel, rightSpeed)\n    sim.setJointTargetVelocity(rearLeftWheel, leftSpeed)\n    sim.setJointTargetVelocity(rearRightWheel, rightSpeed)\n    sim.setJointTargetVelocity(upanddown, up)\n\n# 初始化运动变量\nleftSpeed = 0\nrightSpeed = 0\nup = 0\n\n# 主循环\nwhile True:\n    # 检查键盘输入以设置前进和后退速度\n    if keyboard.is_pressed('w'):\n        leftSpeed = 10  # 前进\n        rightSpeed = 10  # 前进\n    elif keyboard.is_pressed('s'):\n        leftSpeed = -10  # 后退\n        rightSpeed = -10  # 后退\n    else:\n        leftSpeed = 0\n        rightSpeed = 0\n\n    # 检查键盘输入以设置转向速度\n    if keyboard.is_pressed('a'):\n        leftSpeed += 5  # 左转\n        rightSpeed -= 5  # 左转\n    elif keyboard.is_pressed('d'):\n        leftSpeed -= 5  # 右转\n        rightSpeed += 5  # 右转\n\n    # 检查键盘输入以设置升降速度\n    if keyboard.is_pressed('J'):\n        up = 10  # 上升\n    elif keyboard.is_pressed('K'):\n        up = -10  # 下降\n    else:\n        up = 0        \n\n    # 检查键盘输入以退出程序\n    if keyboard.is_pressed('q'):\n        break  # 退出\n\n    # 设置所有轮子的运动\n    setWheelMotion(leftSpeed, rightSpeed, up)\n\n# 停止模拟\nsim.stopSimulation()\n\n\n \n\n# Stop the simulation\nsim.stopSimulation()\n \n 第二版 \n from zmqRemoteApi_IPv6 import RemoteAPIClient\nimport keyboard\n\nclient = RemoteAPIClient('localhost', 23000)\n\nprint('Program started')\nsim = client.getObject('sim')\nsim.startSimulation()\nprint('Simulation started')\n\ndef setWheelMotion(leftSpeed, rightSpeed, up1, up2, up3):\n    # Set target velocity for each wheel\n    frontLeftWheel = sim.getObject('/frontLeftJoint')\n    frontRightWheel = sim.getObject('/frontRightJoint')\n    rearLeftWheel = sim.getObject('/rearLeftJoint')\n    rearRightWheel = sim.getObject('/rearRightJoint')\n    upanddown1 = sim.getObject('/upanddown1')\n    upanddown2 = sim.getObject('/upanddown2')\n    upanddown3 = sim.getObject('/upanddown3')\n    sim.setJointTargetVelocity(frontLeftWheel, leftSpeed)\n    sim.setJointTargetVelocity(frontRightWheel, rightSpeed)\n    sim.setJointTargetVelocity(rearLeftWheel, leftSpeed)\n    sim.setJointTargetVelocity(rearRightWheel, rightSpeed)\n    sim.setJointTargetVelocity(upanddown1,up1)\n    sim.setJointTargetVelocity(upanddown2,up2) \n    sim.setJointTargetVelocity(upanddown3,up3)\n# Initialize motion variables\nleftSpeed = 0\nrightSpeed = 0\nup1 = 0\nup2 = 0\nup3 = 0\n# Main loop\nwhile True:\n    # Check keyboard input\n    if keyboard.is_pressed('w'):\n        leftSpeed = 10  # Forward motion\n        rightSpeed = 10  # Forward motion\n    elif keyboard.is_pressed('s'):\n        leftSpeed = -10  # Backward motion\n        rightSpeed = -10  # Backward motion\n    else:\n        leftSpeed = 0\n        rightSpeed = 0\n\n    if keyboard.is_pressed('a'):\n        leftSpeed -= 5  # Left turn\n        rightSpeed += 5  # Left turn\n    elif keyboard.is_pressed('d'):\n        leftSpeed += 5  # Right turn\n        rightSpeed -= 5  # Right turn\n        \n    if keyboard.is_pressed('1'):\n        up1 = 1  # Forward motion\n    elif keyboard.is_pressed('3'):\n        up1 = -1  # Backward motion\n    else:\n        up1 = 0\n        \n    if keyboard.is_pressed('4'):\n        up2 = 1  # Forward motion\n    elif keyboard.is_pressed('6'):\n        up2 = -1  # Backward motion\n    else:\n        up2 = 0\n        \n    if keyboard.is_pressed('7'):\n        up3 = 1  # Forward motion\n    elif keyboard.is_pressed('9'):\n        up3 = -1  # Backward motion\n    else:\n        up3 = 0\n        \n    if keyboard.is_pressed('q'):\n        break  # Quit\n\n    # Set motion for all wheels\n    setWheelMotion(leftSpeed, rightSpeed, up1, up2, up3)\n\n# Stop the simulation\nsim.stopSimulation() \n", 'tags': '', 'url': '程式-1.html'}, {'title': '球場', 'text': '最初我們利用一條sensor當作得分感測器，由於場上會同時有10顆球，僅需將得分之球重製。一開始我們先加入另外一顆球做測試， 嘗試只將得分之球重製回初始位置。但後來發現 不管哪顆球觸碰到sensor後，兩顆球都會同時回到初始位置。  \n 後續我們建立第二版之測試， 我們將sensor新增至兩條，分別獨立對應得分之球，並希望能將對應之球得分後回到初始位置，但嘗試了幾次，且重複確認程式有無錯誤，還是無法達成預期效果，所以打算放棄sensor，並不斷找尋另一種方法。 \n  最終版本：我們打算利用物體碰撞之效果取代先前的sensor，當作另一種感測器，發現這種方法非常之順利，並達成了預期效果， 改良後我們在 足球門和籃框裡加入碰撞塊當作新一代感測器 ，並關閉其可見性以免阻擋視線，當球觸碰到碰撞塊後，不僅會得分，還能連同將得分之球重製回初始位置，其餘之球一樣在場上作動。我們就將此方法利用在足球門與籃框上，達成目的。 \n \n 進足球門得1分(計分器旋轉36度) \n 進籃框得5分(計分器旋轉180度) \n \n 場地: 長 4m x 寬 2.5m, 外圍以足夠高度之隱形柵欄區隔 \n 競技球: 白色, 直徑 0.1m, 重量 0.5kg \n 籃板: 長 0.3m, 高 0.3m, 寬 0.1m, 位於足球門上方中央 \n 籃框: 由籃板向場內距離 0.1m, 內徑 0.2m, 框管直徑 0.02 \n 足球門: 長 0.6m, 高 0.3m, 寬 0.1m \n', 'tags': '', 'url': '球場.html'}, {'title': '籃框程式', 'text': "function sysCall_init()\n    wheelJoint = sim.getObjectHandle('/joint1g')\n    rim1 = sim.getObject('/Cylinder1') \n    ball1 = sim.getObject('/ball1')\n    ball2 = sim.getObject('/ball2')\n    ball3 = sim.getObject('/ball3')\n    ball4 = sim.getObject('/ball4')\n    ball5 = sim.getObject('/ball5')\n    ball6 = sim.getObject('/ball6')\n    ball7 = sim.getObject('/ball7')\n    ball8 = sim.getObject('/ball8')\n    ball9 = sim.getObject('/ball9')\n    ball10 = sim.getObject('/ball10')\n\nend\n\nfunction sysCall_actuation()\n    collision1= sim.checkCollision(ball1,rim1)\n    collision2= sim.checkCollision(ball2,rim1)\n    collision3= sim.checkCollision(ball3,rim1)\n    collision4= sim.checkCollision(ball4,rim1)\n    collision5= sim.checkCollision(ball5,rim1)\n    collision6= sim.checkCollision(ball6,rim1)\n    collision7= sim.checkCollision(ball7,rim1)\n    collision8= sim.checkCollision(ball8,rim1)\n    collision9= sim.checkCollision(ball9,rim1)\n    collision10= sim.checkCollision(ball10,rim1)\n    if ( collision1 > 0) then\n        sim.setObjectPosition(ball1, -1, {0,0,0.25})\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-180)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision2 > 0) then\n        sim.setObjectPosition(ball2, -1, {0,0,0.25})\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-180)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision3 > 0) then\n        sim.setObjectPosition(ball3, -1, {0,0,0.25})\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-180)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision4 > 0) then\n        sim.setObjectPosition(ball4, -1, {0,0,0.25})\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-180)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision5 > 0) then\n        sim.setObjectPosition(ball5, -1, {0,0,0.25})\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-180)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision6 > 0) then\n        sim.setObjectPosition(ball6, -1, {0,0,0.25})\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-180)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision7 > 0) then\n        sim.setObjectPosition(ball7, -1, {0,0,0.25})\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-180)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision8 > 0) then\n        sim.setObjectPosition(ball8, -1, {0,0,0.25})\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-180)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision9 > 0) then\n        sim.setObjectPosition(ball9, -1, {0,0,0.25})\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-180)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision10 > 0) then\n        sim.setObjectPosition(ball10, -1, {0,0,0.25})\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-180)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n             end\n            end\n           end\n          end\n         end\n        end\n      end\n     end\n    end  \n  end\nend \n \n", 'tags': '', 'url': '籃框程式.html'}, {'title': '足球門程式', 'text': "第一版 \n function sysCall_init()\n    score = 0\n    wheelJoint = sim.getObjectHandle('/joint1g')\n    robot = {\n        sim.getObjectHandle('/basic'),\n    }\n    initialPos = {\n        {-1.050, -0.77134, 0.21},\n        {-1.050, -0.27134, 0.21},\n        {-1.050, 0.22867, 0.21},\n        {-1.050, 0.62866, 0.21},\n    }\n    initialOri = {\n        {90, 90, 0},\n    }\n\nend\n\nsensor = sim.getObject('./sensor')\ninitialPosBall = sim.getObjectPosition(sensor, -1)\nball = sim.getObject('/ball')\n\nfunction sysCall_actuation()\n    result = sim.readProximitySensor(sensor)\n    if (result > 0) then\n        score = score + 1\n        sim.setObjectPosition(ball, -1, {0,0,0.25})\n        \n        -- Rotate the wheel joint by 36 degrees\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-36)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n        \n        for i = 1, 8 do\n            sim.setObjectPosition(robot[i], -1, initialPos[i])\n            sim.setObjectOrientation(robot[i], -1, initialOri[i])\n        end\nend\n\nfunction sysCall_cleanup()\n    sim.setShapeColor(goalHandle, nil, sim.colorcomponent_ambient_diffuse,{0, 0, 0}) \n 第二版 \n function sysCall_init()\n    score = 0\n    wheelJoint = sim.getObjectHandle('/joint1g')\n    robot = {\n        sim.getObjectHandle('/basic'),\n    }\n    initialPos = {\n        {-1.050, -0.77134, 0.21},\n        {-1.050, -0.27134, 0.21},\n        {-1.050, 0.22867, 0.21},\n        {-1.050, 0.62866, 0.21},\n    }\n    initialOri = {\n        {90, 90, 0},\n    }\n\n    sensor1 = sim.getObject('/sensor1') -- 第一个传感器\n    sensor2 = sim.getObject('/sensor2') -- 第二个传感器\n\n    ball1 = sim.getObject('/ball1')\n    ball2 = sim.getObject('/ball2')\nend\n\nfunction sysCall_actuation()\n    result1 = sim.readProximitySensor(sensor1)\n    result2 = sim.readProximitySensor(sensor2)\n    \n    if (result1 > 0 or result2 > 0) then\n        score = score + 1\n        sim.setObjectPosition(ball1, -1, {0,0,0.25})\n        sim.setObjectPosition(ball2, -1, {0,10,0.25})\n        \n        -- Rotate the wheel joint by 36 degrees\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-36)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n        \n\n        -- Rotate the wheel joint by 36 degrees\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-36)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n        \n        for i = 1, 8 do\n\n        end\n        \n        goalEffectEnabled = true\n        lastGoalPlayer = result1 or result2\n        flashingState = false\n        flashingTimer = 0\n end\n    \n\nfunction sysCall_cleanup()\n    sim.setShapeColor(goalHandle, nil, sim.colorcomponent_ambient_diffuse,{0, 0, 0})\nend\n \n 最終版 \n function sysCall_init()\n    wheelJoint = sim.getObjectHandle('/joint1g')\n    door1 = sim.getObject('/Cuboid') \n    ball1 = sim.getObject('/ball1')\n    ball2 = sim.getObject('/ball2')\n    ball3 = sim.getObject('/ball3')\n    ball4 = sim.getObject('/ball4')\n    ball5 = sim.getObject('/ball5')\n    ball6 = sim.getObject('/ball6')\n    ball7 = sim.getObject('/ball7')\n    ball8 = sim.getObject('/ball8')\n    ball9 = sim.getObject('/ball9')\n    ball10 = sim.getObject('/ball10')\n\nend\n\nfunction sysCall_actuation()\n    collision1= sim.checkCollision(ball1,door1)\n    collision2= sim.checkCollision(ball2,door1)\n    collision3= sim.checkCollision(ball3,door1)\n    collision4= sim.checkCollision(ball4,door1)\n    collision5= sim.checkCollision(ball5,door1)\n    collision6= sim.checkCollision(ball6,door1)\n    collision7= sim.checkCollision(ball7,door1)\n    collision8= sim.checkCollision(ball8,door1)\n    collision9= sim.checkCollision(ball9,door1)\n    collision10= sim.checkCollision(ball10,door1)\n    if ( collision1 > 0) then\n        sim.setObjectPosition(ball1, -1, {0,0,0.25})\n        -- Rotate the wheel joint by 36 degrees\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-36)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision2 > 0) then\n        sim.setObjectPosition(ball2, -1, {0,0,0.25})\n        -- Rotate the wheel joint by 36 degrees\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-36)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision3 > 0) then\n        sim.setObjectPosition(ball3, -1, {0,0,0.25})\n        -- Rotate the wheel joint by 36 degrees\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-36)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision4 > 0) then\n        sim.setObjectPosition(ball4, -1, {0,0,0.25})\n        -- Rotate the wheel joint by 36 degrees\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-36)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision5 > 0) then\n        sim.setObjectPosition(ball5, -1, {0,0,0.25})\n        -- Rotate the wheel joint by 36 degrees\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-36)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision6 > 0) then\n        sim.setObjectPosition(ball6, -1, {0,0,0.25})\n        -- Rotate the wheel joint by 36 degrees\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-36)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision7 > 0) then\n        sim.setObjectPosition(ball7, -1, {0,0,0.25})\n        -- Rotate the wheel joint by 36 degrees\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-36)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision8 > 0) then\n        sim.setObjectPosition(ball8, -1, {0,0,0.25})\n        -- Rotate the wheel joint by 36 degrees\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-36)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision9 > 0) then\n        sim.setObjectPosition(ball9, -1, {0,0,0.25})\n        -- Rotate the wheel joint by 36 degrees\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-36)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n    else if ( collision10 > 0) then\n        sim.setObjectPosition(ball10, -1, {0,0,0.25})\n        -- Rotate the wheel joint by 36 degrees\n        local currentAngle = sim.getJointPosition(wheelJoint)\n        local targetAngle = currentAngle + math.rad(-36)\n        sim.setJointTargetPosition(wheelJoint, targetAngle)\n             end\n            end\n           end\n          end\n         end\n        end\n      end\n     end\n    end  \n  end\nend \n \n", 'tags': '', 'url': '足球門程式.html'}, {'title': '機械轉盤計分器', 'text': '得分時個位數轉盤會旋轉(36度or180度) \n 當個位數轉盤旋轉一圈後(數字9to數字0)，會帶動下方小齒輪並驅使十位數轉盤旋轉36度，依此類推。 \n (一分為個位數轉盤36度) \n \n \n', 'tags': '', 'url': '機械轉盤計分器.html'}, {'title': '圖檔-2', 'text': '機械記分板與零件.zip \n', 'tags': '', 'url': '圖檔-2.html'}, {'title': '3D列印之實體計分器', 'text': '', 'tags': '', 'url': '3D列印之實體計分器.html'}, {'title': 'Arduino', 'text': '', 'tags': '', 'url': 'Arduino.html'}, {'title': '電子計時器', 'text': '當遊戲開始時，電子計時器從10分鐘開始倒數，歸零時便會結束本場遊戲。 \n \n', 'tags': '', 'url': '電子計時器.html'}, {'title': '程式-2', 'text': "function sysCall_init()\n    t2=0\n    s0={1,1,1,0,1,1,1}\n    s1={0,0,1,0,0,1,0}\n    s2={1,0,1,1,1,0,1}\n    s3={1,0,1,1,0,1,1}\n    s4={0,1,1,1,0,1,0}\n    s5={1,1,0,1,0,1,1}\n    s6={1,1,0,1,1,1,1}\n    s7={1,0,1,0,0,1,0}\n    s8={1,1,1,1,1,1,1}\n    s9={1,1,1,1,0,1,1}\n    s={s0,s1,s2,s3,s4,s5,s6,s7,s8,s9}\n    \n    score(0,'a')\n    score(0,'b')\n    score(0,'c')\n    score(0,'d')\nend\n\nfunction score(x,y)\n    for i=0 ,9,1 do\n        if (x==i)then\n            for j = 0,6,1 do\n                local part = sim.getObject('./'..y..''..j..'')\n                if (s[i+1][j+1]==1) then\n                    sim.setShapeColor(part, nil, sim.colorcomponent_ambient_diffuse, {1, 0, 0})\n                else\n                    sim.setShapeColor(part, nil, sim.colorcomponent_ambient_diffuse, {0, 0, 0})\n                end\n            end\n        end\n    end\nend\n\nfunction sysCall_actuation()\n    \n    simulationTime = sim.getSimulationTime()\n    simulationTime1=600-simulationTime/3\n\n    t1=math.floor((simulationTime1/600)%10)\n    score(t1,'a')\n    t2=math.floor((simulationTime1/60)%10)\n    score(t2,'b')\n    t3=math.floor((simulationTime1/10)%6)\n    score(t3,'c')\n    t4=math.floor(simulationTime1%10)\n    score(t4,'d')\n    \n    if (simulationTime1<1)then\n        sim.pauseSimulation()\n    end\n    \n    p=sim.getSimulationState()\n    if(p==22)then\n        score(0,'a')\n        score(0,'b')\n        score(0,'c')\n        score(0,'d')\n    end\n        \n    \nend \n", 'tags': '', 'url': '程式-2.html'}, {'title': '協同設定', 'text': '', 'tags': '', 'url': '協同設定.html'}, {'title': '遊戲連線說明', 'text': '1.將防火牆都關閉 \n \n 2.設定特定連接埠並選擇以系統管理員身分執行 \n \n 3.設定IPV6位址 \n \n 4.開啟zmq以及CoppeliaSim(4.5.1) \n \n 5.將Localhost改為組長的IPV6位址 \n \n 6.在瀏覽器輸入http://[組長IP]:23020\xa0 即可觀看場景並連線對戰 \n \n', 'tags': '', 'url': '遊戲連線說明.html'}, {'title': '倉儲維護', 'text': '\n 建立 \xa0 Replit \xa0 帳號 \n 登入 Email 驗證 \xa0 Replit \xa0 寄出的註冊確認電子郵件 \n 利用 import repository, 以 \xa0 cmsite \xa0 倉儲內容, 建立 repl \n 進入 .replit 檔案設定頁面, 將 main.py 設定為啟動程式 \n 在 shell 介面執行 git submodule update --init --recursive, 取下 \xa0 cmsite \xa0 倉儲中 cmsimde 子模組檔案 \n 在 shell 介面執行 pip install flask flask_cors bs4 lxml pelican markdown gevent, 安裝 cmsimde 所需要的模組 \n 按下 Run, 啟動 main.py \n 登入 \xa0 cmsite \xa0 動態網站, 修改管理者密碼, 修改標題與內容後, 以 generate_pages 將動態網頁內容轉為靜態格式 \n 利用 \xa0 Replit \xa0 中的 Version Control 功能, 將改版資料推向遠端倉儲 \n \n', 'tags': '', 'url': '倉儲維護.html'}, {'title': '最終成品展示', 'text': '', 'tags': '', 'url': '最終成品展示.html'}, {'title': '影片展示', 'text': '\n', 'tags': '', 'url': '影片展示.html'}, {'title': '檔案', 'text': '操作程式.7z \n 遊戲最終成品 \n', 'tags': '', 'url': '檔案.html'}, {'title': 'References', 'text': 'https://github.com/mdecd2024/test-ag1 \n https://github.com/mdecd2023/2a3-pj3ag4 \n soccer field image from\xa0 public domain . \n', 'tags': '', 'url': 'References.html'}, {'title': 'Score_counter', 'text': '機械轉盤計分器: \n 原始設計: \n \n 以 SolidWorks 設計繪圖:  scoreboard_solidworks_cd2023_pj3ag4.7z  (由  cd2023 pj3 2a 第四組 完成設計繪圖) \n 本專題將修改設計後納入步進馬達控制轉角, 並利用 Python 程式與 CoppeliaSim 場景伺服器賽局計分器同步作動. \n \n', 'tags': '', 'url': 'Score_counter.html'}, {'title': 'Brython', 'text': 'cmsite: wcms use  https://github.com/mdecycu/cmsimde  as submodule \n https://en.wikipedia.org/wiki/Python_(programming_language) \n Examples: \n https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d \n https://www.geeksforgeeks.org/python-programming-examples/ \n https://www.programiz.com/python-programming/examples \n https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/ \n Python Tutorial: \n https://docs.python.org/3/tutorial/ \n An informal introduction to Python \n Indentation \n Variables \n Comments \n Numbers \n Strings \n print \n Python control flow tools \n for \n if \n range \n open \n read \n lists \n tuples \n dictionaries \n functions \n try ... except \n break \n pass \n classes \n 這個頁面 demo 如何在同一頁面下納入多個線上 Ace 編輯器與執行按鈕 ( practice_html.txt  動態頁面超文件). \n practice_html.txt  動態頁面超文件應該可以在啟動 Brython 時, 設定將 .py 檔案放入 downloads/py 目錄中引用. \n 亦即將所有對應的 html 也使用 Brython 產生, 然後寫為  class  後, 在範例導入時透過  instance  引用. \n <!-- 啟動 Brython -->\n<script>\nwindow.onload=function(){\nbrython({debug:1, pythonpath:[\'./../cmsimde/static/\',\'./../downloads/py/\']});\n}\n</script> \n 從 1 累加到 100: \n 1 add to 100 \n 將 iterable 與 iterator  相關說明 , 利用 Brython 與 Ace Editor 整理在這個頁面. \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n', 'tags': '', 'url': 'Brython.html'}]};